/* tslint:disable */
/* eslint-disable */
/**
 * Phrase Strings API Reference
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@phrase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AffectedCount,
    AffectedCountFromJSON,
    AffectedCountToJSON,
    Translation,
    TranslationFromJSON,
    TranslationToJSON,
    TranslationCreateParameters,
    TranslationCreateParametersFromJSON,
    TranslationCreateParametersToJSON,
    TranslationDetails,
    TranslationDetailsFromJSON,
    TranslationDetailsToJSON,
    TranslationExcludeParameters,
    TranslationExcludeParametersFromJSON,
    TranslationExcludeParametersToJSON,
    TranslationIncludeParameters,
    TranslationIncludeParametersFromJSON,
    TranslationIncludeParametersToJSON,
    TranslationReviewParameters,
    TranslationReviewParametersFromJSON,
    TranslationReviewParametersToJSON,
    TranslationUnverifyParameters,
    TranslationUnverifyParametersFromJSON,
    TranslationUnverifyParametersToJSON,
    TranslationUpdateParameters,
    TranslationUpdateParametersFromJSON,
    TranslationUpdateParametersToJSON,
    TranslationVerifyParameters,
    TranslationVerifyParametersFromJSON,
    TranslationVerifyParametersToJSON,
    TranslationsExcludeParameters,
    TranslationsExcludeParametersFromJSON,
    TranslationsExcludeParametersToJSON,
    TranslationsIncludeParameters,
    TranslationsIncludeParametersFromJSON,
    TranslationsIncludeParametersToJSON,
    TranslationsReviewParameters,
    TranslationsReviewParametersFromJSON,
    TranslationsReviewParametersToJSON,
    TranslationsSearchParameters,
    TranslationsSearchParametersFromJSON,
    TranslationsSearchParametersToJSON,
    TranslationsUnverifyParameters,
    TranslationsUnverifyParametersFromJSON,
    TranslationsUnverifyParametersToJSON,
    TranslationsVerifyParameters,
    TranslationsVerifyParametersFromJSON,
    TranslationsVerifyParametersToJSON,
} from '../models';

export interface TranslationCreateRequest {
    projectId: string;
    translationCreateParameters: TranslationCreateParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationExcludeRequest {
    projectId: string;
    id: string;
    translationExcludeParameters: TranslationExcludeParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationIncludeRequest {
    projectId: string;
    id: string;
    translationIncludeParameters: TranslationIncludeParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationReviewRequest {
    projectId: string;
    id: string;
    translationReviewParameters: TranslationReviewParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationShowRequest {
    projectId: string;
    id: string;
    xPhraseAppOTP?: string;
    branch?: string;
}

export interface TranslationUnverifyRequest {
    projectId: string;
    id: string;
    translationUnverifyParameters: TranslationUnverifyParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationUpdateRequest {
    projectId: string;
    id: string;
    translationUpdateParameters: TranslationUpdateParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationVerifyRequest {
    projectId: string;
    id: string;
    translationVerifyParameters: TranslationVerifyParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationsByKeyRequest {
    projectId: string;
    keyId: string;
    xPhraseAppOTP?: string;
    page?: number;
    perPage?: number;
    branch?: string;
    sort?: string;
    order?: string;
    q?: string;
}

export interface TranslationsByLocaleRequest {
    projectId: string;
    localeId: string;
    xPhraseAppOTP?: string;
    page?: number;
    perPage?: number;
    branch?: string;
    sort?: string;
    order?: string;
    q?: string;
}

export interface TranslationsExcludeCollectionRequest {
    projectId: string;
    translationsExcludeParameters: TranslationsExcludeParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationsIncludeCollectionRequest {
    projectId: string;
    translationsIncludeParameters: TranslationsIncludeParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationsListRequest {
    projectId: string;
    xPhraseAppOTP?: string;
    ifModifiedSince?: string;
    ifNoneMatch?: string;
    page?: number;
    perPage?: number;
    branch?: string;
    sort?: string;
    order?: string;
    q?: string;
}

export interface TranslationsReviewCollectionRequest {
    projectId: string;
    translationsReviewParameters: TranslationsReviewParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationsSearchRequest {
    projectId: string;
    translationsSearchParameters: TranslationsSearchParameters;
    xPhraseAppOTP?: string;
    page?: number;
    perPage?: number;
}

export interface TranslationsUnverifyCollectionRequest {
    projectId: string;
    translationsUnverifyParameters: TranslationsUnverifyParameters;
    xPhraseAppOTP?: string;
}

export interface TranslationsVerifyCollectionRequest {
    projectId: string;
    translationsVerifyParameters: TranslationsVerifyParameters;
    xPhraseAppOTP?: string;
}

/**
 * 
 */
export class TranslationsApi extends runtime.BaseAPI {

    /**
     * Create a translation.
     * Create a translation
     */
    async translationCreateRaw(requestParameters: TranslationCreateRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationCreate.');
        }

        if (requestParameters.translationCreateParameters === null || requestParameters.translationCreateParameters === undefined) {
            throw new runtime.RequiredError('translationCreateParameters','Required parameter requestParameters.translationCreateParameters was null or undefined when calling translationCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationCreateParametersToJSON(requestParameters.translationCreateParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Create a translation.
     * Create a translation
     */
    async translationCreate(requestParameters: TranslationCreateRequest): Promise<TranslationDetails> {
        const response = await this.translationCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set exclude from export flag on an existing translation.
     * Exclude a translation from export
     */
    async translationExcludeRaw(requestParameters: TranslationExcludeRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationExclude.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationExclude.');
        }

        if (requestParameters.translationExcludeParameters === null || requestParameters.translationExcludeParameters === undefined) {
            throw new runtime.RequiredError('translationExcludeParameters','Required parameter requestParameters.translationExcludeParameters was null or undefined when calling translationExclude.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}/exclude`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationExcludeParametersToJSON(requestParameters.translationExcludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Set exclude from export flag on an existing translation.
     * Exclude a translation from export
     */
    async translationExclude(requestParameters: TranslationExcludeRequest): Promise<TranslationDetails> {
        const response = await this.translationExcludeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Remove exclude from export flag from an existing translation.
     * Include a translation
     */
    async translationIncludeRaw(requestParameters: TranslationIncludeRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationInclude.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationInclude.');
        }

        if (requestParameters.translationIncludeParameters === null || requestParameters.translationIncludeParameters === undefined) {
            throw new runtime.RequiredError('translationIncludeParameters','Required parameter requestParameters.translationIncludeParameters was null or undefined when calling translationInclude.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}/include`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationIncludeParametersToJSON(requestParameters.translationIncludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Remove exclude from export flag from an existing translation.
     * Include a translation
     */
    async translationInclude(requestParameters: TranslationIncludeRequest): Promise<TranslationDetails> {
        const response = await this.translationIncludeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Mark an existing translation as reviewed.
     * Review a translation
     */
    async translationReviewRaw(requestParameters: TranslationReviewRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationReview.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationReview.');
        }

        if (requestParameters.translationReviewParameters === null || requestParameters.translationReviewParameters === undefined) {
            throw new runtime.RequiredError('translationReviewParameters','Required parameter requestParameters.translationReviewParameters was null or undefined when calling translationReview.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}/review`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationReviewParametersToJSON(requestParameters.translationReviewParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Mark an existing translation as reviewed.
     * Review a translation
     */
    async translationReview(requestParameters: TranslationReviewRequest): Promise<TranslationDetails> {
        const response = await this.translationReviewRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get details on a single translation.
     * Get a single translation
     */
    async translationShowRaw(requestParameters: TranslationShowRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationShow.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationShow.');
        }

        const queryParameters: any = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Get details on a single translation.
     * Get a single translation
     */
    async translationShow(requestParameters: TranslationShowRequest): Promise<TranslationDetails> {
        const response = await this.translationShowRaw(requestParameters);
        return await response.value();
    }

    /**
     * Mark an existing translation as unverified.
     * Mark a translation as unverified
     */
    async translationUnverifyRaw(requestParameters: TranslationUnverifyRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationUnverify.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationUnverify.');
        }

        if (requestParameters.translationUnverifyParameters === null || requestParameters.translationUnverifyParameters === undefined) {
            throw new runtime.RequiredError('translationUnverifyParameters','Required parameter requestParameters.translationUnverifyParameters was null or undefined when calling translationUnverify.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}/unverify`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationUnverifyParametersToJSON(requestParameters.translationUnverifyParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Mark an existing translation as unverified.
     * Mark a translation as unverified
     */
    async translationUnverify(requestParameters: TranslationUnverifyRequest): Promise<TranslationDetails> {
        const response = await this.translationUnverifyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing translation.
     * Update a translation
     */
    async translationUpdateRaw(requestParameters: TranslationUpdateRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationUpdate.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationUpdate.');
        }

        if (requestParameters.translationUpdateParameters === null || requestParameters.translationUpdateParameters === undefined) {
            throw new runtime.RequiredError('translationUpdateParameters','Required parameter requestParameters.translationUpdateParameters was null or undefined when calling translationUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationUpdateParametersToJSON(requestParameters.translationUpdateParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Update an existing translation.
     * Update a translation
     */
    async translationUpdate(requestParameters: TranslationUpdateRequest): Promise<TranslationDetails> {
        const response = await this.translationUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verify an existing translation.
     * Verify a translation
     */
    async translationVerifyRaw(requestParameters: TranslationVerifyRequest): Promise<runtime.ApiResponse<TranslationDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationVerify.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translationVerify.');
        }

        if (requestParameters.translationVerifyParameters === null || requestParameters.translationVerifyParameters === undefined) {
            throw new runtime.RequiredError('translationVerifyParameters','Required parameter requestParameters.translationVerifyParameters was null or undefined when calling translationVerify.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/{id}/verify`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationVerifyParametersToJSON(requestParameters.translationVerifyParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationDetailsFromJSON(jsonValue));
    }

    /**
     * Verify an existing translation.
     * Verify a translation
     */
    async translationVerify(requestParameters: TranslationVerifyRequest): Promise<TranslationDetails> {
        const response = await this.translationVerifyRaw(requestParameters);
        return await response.value();
    }

    /**
     * List translations for a specific key.
     * List translations by key
     */
    async translationsByKeyRaw(requestParameters: TranslationsByKeyRequest): Promise<runtime.ApiResponse<Array<Translation>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsByKey.');
        }

        if (requestParameters.keyId === null || requestParameters.keyId === undefined) {
            throw new runtime.RequiredError('keyId','Required parameter requestParameters.keyId was null or undefined when calling translationsByKey.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/{key_id}/translations`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"key_id"}}`, encodeURIComponent(String(requestParameters.keyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationFromJSON));
    }

    /**
     * List translations for a specific key.
     * List translations by key
     */
    async translationsByKey(requestParameters: TranslationsByKeyRequest): Promise<Array<Translation>> {
        const response = await this.translationsByKeyRaw(requestParameters);
        return await response.value();
    }

    /**
     * List translations for a specific locale. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * List translations by locale
     */
    async translationsByLocaleRaw(requestParameters: TranslationsByLocaleRequest): Promise<runtime.ApiResponse<Array<Translation>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsByLocale.');
        }

        if (requestParameters.localeId === null || requestParameters.localeId === undefined) {
            throw new runtime.RequiredError('localeId','Required parameter requestParameters.localeId was null or undefined when calling translationsByLocale.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/locales/{locale_id}/translations`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"locale_id"}}`, encodeURIComponent(String(requestParameters.localeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationFromJSON));
    }

    /**
     * List translations for a specific locale. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * List translations by locale
     */
    async translationsByLocale(requestParameters: TranslationsByLocaleRequest): Promise<Array<Translation>> {
        const response = await this.translationsByLocaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Exclude translations matching query from locale export.
     * Exclude translations by query
     */
    async translationsExcludeCollectionRaw(requestParameters: TranslationsExcludeCollectionRequest): Promise<runtime.ApiResponse<AffectedCount>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsExcludeCollection.');
        }

        if (requestParameters.translationsExcludeParameters === null || requestParameters.translationsExcludeParameters === undefined) {
            throw new runtime.RequiredError('translationsExcludeParameters','Required parameter requestParameters.translationsExcludeParameters was null or undefined when calling translationsExcludeCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/exclude`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsExcludeParametersToJSON(requestParameters.translationsExcludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedCountFromJSON(jsonValue));
    }

    /**
     * Exclude translations matching query from locale export.
     * Exclude translations by query
     */
    async translationsExcludeCollection(requestParameters: TranslationsExcludeCollectionRequest): Promise<AffectedCount> {
        const response = await this.translationsExcludeCollectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Include translations matching query in locale export.
     * Include translations by query
     */
    async translationsIncludeCollectionRaw(requestParameters: TranslationsIncludeCollectionRequest): Promise<runtime.ApiResponse<AffectedCount>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsIncludeCollection.');
        }

        if (requestParameters.translationsIncludeParameters === null || requestParameters.translationsIncludeParameters === undefined) {
            throw new runtime.RequiredError('translationsIncludeParameters','Required parameter requestParameters.translationsIncludeParameters was null or undefined when calling translationsIncludeCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/include`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsIncludeParametersToJSON(requestParameters.translationsIncludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedCountFromJSON(jsonValue));
    }

    /**
     * Include translations matching query in locale export.
     * Include translations by query
     */
    async translationsIncludeCollection(requestParameters: TranslationsIncludeCollectionRequest): Promise<AffectedCount> {
        const response = await this.translationsIncludeCollectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * List translations for the given project. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * List all translations
     */
    async translationsListRaw(requestParameters: TranslationsListRequest): Promise<runtime.ApiResponse<Array<Translation>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsList.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (requestParameters.ifModifiedSince !== undefined && requestParameters.ifModifiedSince !== null) {
            headerParameters['If-Modified-Since'] = String(requestParameters.ifModifiedSince);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationFromJSON));
    }

    /**
     * List translations for the given project. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * List all translations
     */
    async translationsList(requestParameters: TranslationsListRequest): Promise<Array<Translation>> {
        const response = await this.translationsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Review translations matching query.
     * Review translations selected by query
     */
    async translationsReviewCollectionRaw(requestParameters: TranslationsReviewCollectionRequest): Promise<runtime.ApiResponse<AffectedCount>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsReviewCollection.');
        }

        if (requestParameters.translationsReviewParameters === null || requestParameters.translationsReviewParameters === undefined) {
            throw new runtime.RequiredError('translationsReviewParameters','Required parameter requestParameters.translationsReviewParameters was null or undefined when calling translationsReviewCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/review`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsReviewParametersToJSON(requestParameters.translationsReviewParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedCountFromJSON(jsonValue));
    }

    /**
     * Review translations matching query.
     * Review translations selected by query
     */
    async translationsReviewCollection(requestParameters: TranslationsReviewCollectionRequest): Promise<AffectedCount> {
        const response = await this.translationsReviewCollectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Search translations for the given project. Provides the same search interface as <code>translations#index</code> but allows POST requests to avoid limitations imposed by GET requests. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * Search translations
     */
    async translationsSearchRaw(requestParameters: TranslationsSearchRequest): Promise<runtime.ApiResponse<Array<Translation>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsSearch.');
        }

        if (requestParameters.translationsSearchParameters === null || requestParameters.translationsSearchParameters === undefined) {
            throw new runtime.RequiredError('translationsSearchParameters','Required parameter requestParameters.translationsSearchParameters was null or undefined when calling translationsSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/search`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsSearchParametersToJSON(requestParameters.translationsSearchParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationFromJSON));
    }

    /**
     * Search translations for the given project. Provides the same search interface as <code>translations#index</code> but allows POST requests to avoid limitations imposed by GET requests. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
     * Search translations
     */
    async translationsSearch(requestParameters: TranslationsSearchRequest): Promise<Array<Translation>> {
        const response = await this.translationsSearchRaw(requestParameters);
        return await response.value();
    }

    /**
     * Mark translations matching query as unverified.
     * Unverify translations by query
     */
    async translationsUnverifyCollectionRaw(requestParameters: TranslationsUnverifyCollectionRequest): Promise<runtime.ApiResponse<AffectedCount>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsUnverifyCollection.');
        }

        if (requestParameters.translationsUnverifyParameters === null || requestParameters.translationsUnverifyParameters === undefined) {
            throw new runtime.RequiredError('translationsUnverifyParameters','Required parameter requestParameters.translationsUnverifyParameters was null or undefined when calling translationsUnverifyCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/unverify`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsUnverifyParametersToJSON(requestParameters.translationsUnverifyParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedCountFromJSON(jsonValue));
    }

    /**
     * Mark translations matching query as unverified.
     * Unverify translations by query
     */
    async translationsUnverifyCollection(requestParameters: TranslationsUnverifyCollectionRequest): Promise<AffectedCount> {
        const response = await this.translationsUnverifyCollectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verify translations matching query.
     * Verify translations by query
     */
    async translationsVerifyCollectionRaw(requestParameters: TranslationsVerifyCollectionRequest): Promise<runtime.ApiResponse<AffectedCount>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling translationsVerifyCollection.');
        }

        if (requestParameters.translationsVerifyParameters === null || requestParameters.translationsVerifyParameters === undefined) {
            throw new runtime.RequiredError('translationsVerifyParameters','Required parameter requestParameters.translationsVerifyParameters was null or undefined when calling translationsVerifyCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/translations/verify`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationsVerifyParametersToJSON(requestParameters.translationsVerifyParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedCountFromJSON(jsonValue));
    }

    /**
     * Verify translations matching query.
     * Verify translations by query
     */
    async translationsVerifyCollection(requestParameters: TranslationsVerifyCollectionRequest): Promise<AffectedCount> {
        const response = await this.translationsVerifyCollectionRaw(requestParameters);
        return await response.value();
    }

}
