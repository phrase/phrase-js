/* tslint:disable */
/* eslint-disable */
/**
 * Phrase Strings API Reference
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@phrase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AffectedResources,
    AffectedResourcesFromJSON,
    AffectedResourcesToJSON,
    KeyCreateParameters,
    KeyCreateParametersFromJSON,
    KeyCreateParametersToJSON,
    KeyUpdateParameters,
    KeyUpdateParametersFromJSON,
    KeyUpdateParametersToJSON,
    KeysExcludeParameters,
    KeysExcludeParametersFromJSON,
    KeysExcludeParametersToJSON,
    KeysIncludeParameters,
    KeysIncludeParametersFromJSON,
    KeysIncludeParametersToJSON,
    KeysSearchParameters,
    KeysSearchParametersFromJSON,
    KeysSearchParametersToJSON,
    KeysTagParameters,
    KeysTagParametersFromJSON,
    KeysTagParametersToJSON,
    KeysUntagParameters,
    KeysUntagParametersFromJSON,
    KeysUntagParametersToJSON,
    TranslationKey,
    TranslationKeyFromJSON,
    TranslationKeyToJSON,
    TranslationKeyDetails,
    TranslationKeyDetailsFromJSON,
    TranslationKeyDetailsToJSON,
} from '../models';

export interface KeyCreateRequest {
    projectId: string;
    keyCreateParameters: KeyCreateParameters;
    xPhraseAppOTP?: string;
}

export interface KeyDeleteRequest {
    projectId: string;
    id: string;
    xPhraseAppOTP?: string;
    branch?: string;
}

export interface KeyShowRequest {
    projectId: string;
    id: string;
    xPhraseAppOTP?: string;
    branch?: string;
}

export interface KeyUpdateRequest {
    projectId: string;
    id: string;
    keyUpdateParameters: KeyUpdateParameters;
    xPhraseAppOTP?: string;
}

export interface KeysDeleteCollectionRequest {
    projectId: string;
    xPhraseAppOTP?: string;
    branch?: string;
    q?: string;
    localeId?: string;
}

export interface KeysExcludeRequest {
    projectId: string;
    keysExcludeParameters: KeysExcludeParameters;
    xPhraseAppOTP?: string;
}

export interface KeysIncludeRequest {
    projectId: string;
    keysIncludeParameters: KeysIncludeParameters;
    xPhraseAppOTP?: string;
}

export interface KeysListRequest {
    projectId: string;
    xPhraseAppOTP?: string;
    page?: number;
    perPage?: number;
    branch?: string;
    sort?: string;
    order?: string;
    q?: string;
    localeId?: string;
}

export interface KeysSearchRequest {
    projectId: string;
    keysSearchParameters: KeysSearchParameters;
    xPhraseAppOTP?: string;
    page?: number;
    perPage?: number;
}

export interface KeysTagRequest {
    projectId: string;
    keysTagParameters: KeysTagParameters;
    xPhraseAppOTP?: string;
}

export interface KeysUntagRequest {
    projectId: string;
    keysUntagParameters: KeysUntagParameters;
    xPhraseAppOTP?: string;
}

/**
 * 
 */
export class KeysApi extends runtime.BaseAPI {

    /**
     * Create a new key.
     * Create a key
     */
    async keyCreateRaw(requestParameters: KeyCreateRequest): Promise<runtime.ApiResponse<TranslationKeyDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keyCreate.');
        }

        if (requestParameters.keyCreateParameters === null || requestParameters.keyCreateParameters === undefined) {
            throw new runtime.RequiredError('keyCreateParameters','Required parameter requestParameters.keyCreateParameters was null or undefined when calling keyCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeyCreateParametersToJSON(requestParameters.keyCreateParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationKeyDetailsFromJSON(jsonValue));
    }

    /**
     * Create a new key.
     * Create a key
     */
    async keyCreate(requestParameters: KeyCreateRequest): Promise<TranslationKeyDetails> {
        const response = await this.keyCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an existing key.
     * Delete a key
     */
    async keyDeleteRaw(requestParameters: KeyDeleteRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keyDelete.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling keyDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/{id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete an existing key.
     * Delete a key
     */
    async keyDelete(requestParameters: KeyDeleteRequest): Promise<any> {
        const response = await this.keyDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get details on a single key for a given project.
     * Get a single key
     */
    async keyShowRaw(requestParameters: KeyShowRequest): Promise<runtime.ApiResponse<TranslationKeyDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keyShow.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling keyShow.');
        }

        const queryParameters: any = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/{id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationKeyDetailsFromJSON(jsonValue));
    }

    /**
     * Get details on a single key for a given project.
     * Get a single key
     */
    async keyShow(requestParameters: KeyShowRequest): Promise<TranslationKeyDetails> {
        const response = await this.keyShowRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing key.
     * Update a key
     */
    async keyUpdateRaw(requestParameters: KeyUpdateRequest): Promise<runtime.ApiResponse<TranslationKeyDetails>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keyUpdate.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling keyUpdate.');
        }

        if (requestParameters.keyUpdateParameters === null || requestParameters.keyUpdateParameters === undefined) {
            throw new runtime.RequiredError('keyUpdateParameters','Required parameter requestParameters.keyUpdateParameters was null or undefined when calling keyUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/{id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeyUpdateParametersToJSON(requestParameters.keyUpdateParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslationKeyDetailsFromJSON(jsonValue));
    }

    /**
     * Update an existing key.
     * Update a key
     */
    async keyUpdate(requestParameters: KeyUpdateRequest): Promise<TranslationKeyDetails> {
        const response = await this.keyUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete all keys matching query. Same constraints as list. Please limit the number of affected keys to about 1,000 as you might experience timeouts otherwise.
     * Delete collection of keys
     */
    async keysDeleteCollectionRaw(requestParameters: KeysDeleteCollectionRequest): Promise<runtime.ApiResponse<AffectedResources>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysDeleteCollection.');
        }

        const queryParameters: any = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.localeId !== undefined) {
            queryParameters['locale_id'] = requestParameters.localeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedResourcesFromJSON(jsonValue));
    }

    /**
     * Delete all keys matching query. Same constraints as list. Please limit the number of affected keys to about 1,000 as you might experience timeouts otherwise.
     * Delete collection of keys
     */
    async keysDeleteCollection(requestParameters: KeysDeleteCollectionRequest): Promise<AffectedResources> {
        const response = await this.keysDeleteCollectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Exclude a locale on keys matching query. Same constraints as list.
     * Exclude a locale on a collection of keys
     */
    async keysExcludeRaw(requestParameters: KeysExcludeRequest): Promise<runtime.ApiResponse<AffectedResources>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysExclude.');
        }

        if (requestParameters.keysExcludeParameters === null || requestParameters.keysExcludeParameters === undefined) {
            throw new runtime.RequiredError('keysExcludeParameters','Required parameter requestParameters.keysExcludeParameters was null or undefined when calling keysExclude.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/exclude`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeysExcludeParametersToJSON(requestParameters.keysExcludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedResourcesFromJSON(jsonValue));
    }

    /**
     * Exclude a locale on keys matching query. Same constraints as list.
     * Exclude a locale on a collection of keys
     */
    async keysExclude(requestParameters: KeysExcludeRequest): Promise<AffectedResources> {
        const response = await this.keysExcludeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Include a locale on keys matching query. Same constraints as list.
     * Include a locale on a collection of keys
     */
    async keysIncludeRaw(requestParameters: KeysIncludeRequest): Promise<runtime.ApiResponse<AffectedResources>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysInclude.');
        }

        if (requestParameters.keysIncludeParameters === null || requestParameters.keysIncludeParameters === undefined) {
            throw new runtime.RequiredError('keysIncludeParameters','Required parameter requestParameters.keysIncludeParameters was null or undefined when calling keysInclude.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/include`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeysIncludeParametersToJSON(requestParameters.keysIncludeParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedResourcesFromJSON(jsonValue));
    }

    /**
     * Include a locale on keys matching query. Same constraints as list.
     * Include a locale on a collection of keys
     */
    async keysInclude(requestParameters: KeysIncludeRequest): Promise<AffectedResources> {
        const response = await this.keysIncludeRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all keys for the given project. Alternatively you can POST requests to /search.
     * List keys
     */
    async keysListRaw(requestParameters: KeysListRequest): Promise<runtime.ApiResponse<Array<TranslationKey>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysList.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.localeId !== undefined) {
            queryParameters['locale_id'] = requestParameters.localeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationKeyFromJSON));
    }

    /**
     * List all keys for the given project. Alternatively you can POST requests to /search.
     * List keys
     */
    async keysList(requestParameters: KeysListRequest): Promise<Array<TranslationKey>> {
        const response = await this.keysListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Search keys for the given project matching query.
     * Search keys
     */
    async keysSearchRaw(requestParameters: KeysSearchRequest): Promise<runtime.ApiResponse<Array<TranslationKey>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysSearch.');
        }

        if (requestParameters.keysSearchParameters === null || requestParameters.keysSearchParameters === undefined) {
            throw new runtime.RequiredError('keysSearchParameters','Required parameter requestParameters.keysSearchParameters was null or undefined when calling keysSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/search`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeysSearchParametersToJSON(requestParameters.keysSearchParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TranslationKeyFromJSON));
    }

    /**
     * Search keys for the given project matching query.
     * Search keys
     */
    async keysSearch(requestParameters: KeysSearchRequest): Promise<Array<TranslationKey>> {
        const response = await this.keysSearchRaw(requestParameters);
        return await response.value();
    }

    /**
     * Tags all keys matching query. Same constraints as list.
     * Add tags to collection of keys
     */
    async keysTagRaw(requestParameters: KeysTagRequest): Promise<runtime.ApiResponse<AffectedResources>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysTag.');
        }

        if (requestParameters.keysTagParameters === null || requestParameters.keysTagParameters === undefined) {
            throw new runtime.RequiredError('keysTagParameters','Required parameter requestParameters.keysTagParameters was null or undefined when calling keysTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/tag`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeysTagParametersToJSON(requestParameters.keysTagParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedResourcesFromJSON(jsonValue));
    }

    /**
     * Tags all keys matching query. Same constraints as list.
     * Add tags to collection of keys
     */
    async keysTag(requestParameters: KeysTagRequest): Promise<AffectedResources> {
        const response = await this.keysTagRaw(requestParameters);
        return await response.value();
    }

    /**
     * Removes specified tags from keys matching query.
     * Remove tags from collection of keys
     */
    async keysUntagRaw(requestParameters: KeysUntagRequest): Promise<runtime.ApiResponse<AffectedResources>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling keysUntag.');
        }

        if (requestParameters.keysUntagParameters === null || requestParameters.keysUntagParameters === undefined) {
            throw new runtime.RequiredError('keysUntagParameters','Required parameter requestParameters.keysUntagParameters was null or undefined when calling keysUntag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xPhraseAppOTP !== undefined && requestParameters.xPhraseAppOTP !== null) {
            headerParameters['X-PhraseApp-OTP'] = String(requestParameters.xPhraseAppOTP);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project_id}/keys/untag`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeysUntagParametersToJSON(requestParameters.keysUntagParameters),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AffectedResourcesFromJSON(jsonValue));
    }

    /**
     * Removes specified tags from keys matching query.
     * Remove tags from collection of keys
     */
    async keysUntag(requestParameters: KeysUntagRequest): Promise<AffectedResources> {
        const response = await this.keysUntagRaw(requestParameters);
        return await response.value();
    }

}
